
TODO plan:
s1{
    Авторизация через Spring Security
    Редактирование и удаление сообщений
    Cookie
    Видео звонки на WebRTC
    Redis для кэширования
}

s2{
    Документация по проекту
    Тесты
    CI/CD
    Уведомления
}

s3{
    S3 для хранения файлов
    chakra ui
}

Принципы проекта{
    Zero Trust Security
}




## План: Внедрение видеозвонков на WebRTC в мессенджер

Внедрение видеозвонков с использованием WebRTC требует изменений на фронтенде (React), бэкенде (Spring Boot), websocket-сервере, а также проработки вопросов безопасности, масштабируемости, интеграции, UI/UX и тестирования. План разбит на этапы с конкретными задачами для разработки, тестирования и внедрения.

### Этап 1. Анализ и проектирование
1. Проанализировать текущую архитектуру: [front_messenger/src/], [Authorization_service/src/], [websocket_server/src/].
2. Спроектировать поток видеозвонка: peer-to-peer для 1:1, SFU/MCU для групповых.
3. Определить требования к безопасности: шифрование, авторизация, антиспам.
4. Согласовать API для сигнализации WebRTC через websocket-сервер.
5. Спланировать интеграцию с существующими сервисами (авторизация, хранение истории, уведомления).

### Этап 2. Разработка фронтенда (React)
1. Реализовать UI для видеозвонков: кнопки вызова, экран звонка, управление (микрофон, камера, завершение).
2. Интегрировать WebRTC: создание peer connection, обработка media stream, обмен SDP/ICE через websocket.
3. Добавить обработку групповых звонков: подключение к SFU/MCU, отображение нескольких потоков.
4. Обеспечить обработку ошибок, уведомления, fallback сценарии.
5. Интегрировать с существующими страницами и сервисами (авторизация, контакты).

### Этап 3. Разработка бэкенда (Spring Boot + websocket-сервер)
1. Расширить websocket-сервер для сигнализации WebRTC: обмен SDP/ICE, управление комнатами.
2. Реализовать авторизацию и проверку прав на звонок.
3. Добавить защиту от спама: лимиты, капча, блокировка подозрительных действий.
4. Интегрировать с SFU/MCU (например, Janus, Jitsi) для групповых звонков.
5. Обеспечить логирование и мониторинг звонков.

### Этап 4. Безопасность и масштабируемость
1. Внедрить end-to-end шифрование медиа-трафика (SRTP).
2. Реализовать авторизацию на всех этапах звонка.
3. Настроить масштабируемую инфраструктуру для SFU/MCU (Docker, Kubernetes).
4. Провести нагрузочное тестирование peer-to-peer и групповых звонков.

### Этап 5. UI/UX и интеграция
1. Провести UX-исследование: сценарии звонков, уведомления, ошибки.
2. Доработать дизайн интерфейса видеозвонков.
3. Интегрировать видеозвонки с существующими сервисами (чат, уведомления, история).
4. Обеспечить кросс-платформенность (мобильные браузеры, десктоп).

### Этап 6. Тестирование и внедрение
1. Разработать тест-кейсы: функциональные, нагрузочные, безопасность.
2. Провести ручное и автоматизированное тестирование.
3. Организовать beta-тестирование с реальными пользователями.
4. Подготовить документацию для пользователей и администраторов.
5. Внедрить фичу поэтапно: сначала 1:1, затем групповые звонки.

### Дополнительные аспекты
1. Обсудить выбор SFU/MCU: Janus, Jitsi, Mediasoup.
2. Оценить затраты на инфраструктуру и поддержание серверов.
3. Продумать обратную совместимость и миграцию данных.

---

## Рекомендации по технологиям для профессионального внедрения видеозвонков

1. **WebRTC** — для передачи аудио/видео между клиентами. Стандарт для браузеров, поддерживает peer-to-peer, шифрование, низкую задержку.
2. **SFU (Selective Forwarding Unit)** — для групповых звонков. Рекомендуемые решения: Jitsi Videobridge, Janus, Mediasoup. SFU масштабирует видеоконференции, снижает нагрузку на клиентов и сеть.
3. **WebSocket** — для сигнализации (обмена SDP/ICE, управления звонками). Уже используется в проекте, легко расширяется для передачи служебных сообщений WebRTC.
4. **SRTP (Secure Real-time Transport Protocol)** — для шифрования медиа-трафика, встроен в WebRTC.
5. **Docker/Kubernetes** — для контейнеризации и масштабирования серверов SFU, обеспечения отказоустойчивости.
6. **OAuth2/JWT** — для авторизации пользователей при подключении к звонкам, интеграции с существующей системой.
7. **TURN/STUN серверы** (например, coturn) — для обхода NAT и обеспечения стабильного соединения между клиентами.


## Пошаговый план внедрения WebRTC для видеозвонков

1. Анализ архитектуры:
   - Изучить текущий обмен сообщениями через WebSocket.
   - Определить, где будет храниться логика видеозвонков (фронтенд, websocket-сервер, бэкенд).

2. Подготовка фронтенда (React):
   - Добавить компонент видеозвонка (например, VideoCall.jsx).
   - Реализовать захват медиа: использовать navigator.mediaDevices.getUserMedia для получения аудио/видео.
   - Создать PeerConnection (RTCPeerConnection) для WebRTC.
   - Реализовать обработку событий: onicecandidate, ontrack, onnegotiationneeded.
   - Добавить UI: кнопки вызова, завершения, управления микрофоном/камерой.

3. Сигнализация через WebSocket:
   - Расширить протокол WebSocket для передачи SDP и ICE-кандидатов между пользователями.
   - Реализовать обработку сообщений типа “call-offer”, “call-answer”, “ice-candidate”.

4. Интеграция с бэкендом:
   - Проверить авторизацию пользователя при инициации звонка.
   - Добавить логику создания/закрытия комнат для звонков.
   - Реализовать хранение истории звонков (по необходимости).

5. TURN/STUN серверы:
   - Настроить публичный STUN-сервер (например, Google STUN).
   - Развернуть собственный TURN-сервер (например, coturn) для обхода NAT.

6. Безопасность:
   - Убедиться, что WebRTC использует SRTP (по умолчанию).
   - Реализовать проверку прав доступа к звонкам.
   - Защитить WebSocket от несанкционированных подключений (JWT, OAuth2).

7. Тестирование:
   - Провести тесты peer-to-peer звонков между разными сетями и устройствами.
   - Проверить работу через NAT, мобильные и десктопные браузеры.
   - Оценить качество связи, задержки, устойчивость к ошибкам.

8. Документирование и внедрение:
   - Подготовить инструкции для пользователей.
   - Внедрить фичу сначала для 1:1 звонков, затем для групповых (с SFU).

---

## Профессиональное расширение архитектуры для видеозвонков

1. **Фронтенд (React):**
   - Добавить компонент видеозвонка (VideoCall.jsx).
   - Интегрировать WebRTC: захват медиа, peer connection, обработка сигнализации.
   - UI для управления звонком, отображения видео, статусов.

2. **WebSocket-сервер:**
   - Расширить протокол для передачи SDP/ICE сообщений (WebRTC сигнализация).
   - Управление комнатами/сессиями звонков.
   - Авторизация и контроль доступа к звонкам.

3. **Бэкенд (Spring Boot):**
   - Проверка прав пользователя, хранение истории звонков (по необходимости).
   - Интеграция с SFU/MCU для групповых звонков (через REST/WebSocket API).

4. **ICE/STUN/TURN:**
   - ICE реализуется на клиенте (WebRTC), отдельный модуль не требуется.
   - Для peer-to-peer звонков достаточно публичного STUN-сервера (например, Google STUN).
   - Для обхода NAT и стабильности — развернуть собственный TURN-сервер (например, coturn).
   - TURN/STUN рекомендуется вынести в отдельный инфраструктурный сервис (docker-контейнер, отдельный модуль).

5. **SFU/MCU:**
   - Для групповых звонков интегрировать SFU (Jitsi, Janus, Mediasoup) как отдельный сервис.
   - Связь с SFU через WebSocket или REST API.

6. **Безопасность:**
   - SRTP для шифрования медиа.
   - JWT/OAuth2 для авторизации.
   - Логирование и мониторинг звонков.

**Рекомендация:**
- ICE реализуется на клиенте, отдельный модуль не нужен.
- STUN/TURN серверы — отдельный инфраструктурный сервис (docker-контейнер, отдельный модуль).
- SFU/MCU — отдельный сервис для групповых звонков.

---

Фронтенд (React):
Компоненты видеозвонка, обработка медиа, сигнализация, UI/UX: 600–1200 строк.

Сервер сигнализации (WebSocket):
Расширение протокола, обработка комнат, обмен SDP/ICE: 300–600 строк.

Бэкенд (Spring Boot):
Авторизация, хранение истории, интеграция с SFU: 200–400 строк.

Интеграция с TURN/STUN, SFU (Docker/Kubernetes, конфиги): 100–300 строк (скрипты, настройки).
Тесты (unit, e2e): 200–400 строк.
